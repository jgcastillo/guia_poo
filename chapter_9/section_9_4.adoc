== Patrón Strategy

El patrón Strategy pertenece al grupo de patrones de comportamiento. Este patrón permite definir una familia de algoritmos, encapsular cada uno de ellos y hacerlos intercambiables. El patrón Strategy permite que el algoritmo varíe independientemente de los clientes que lo utilizan.

El patrón Strategy surge de la necesidad de tener un diseño flexible y reusable para algoritmos que pueden cambiar con el tiempo. En lugar de tener múltiples condiciones o casos dentro de una clase para manejar diferentes algoritmos, el patrón Strategy permite delegar la responsabilidad a objetos específicos que implementan el algoritmo. Esto mejora la mantenibilidad y facilita la extensión del código sin modificar el contexto que utiliza estos algoritmos.

Para implementar el patrón Strategy, se define una interfaz que declara el método que implementará el algoritmo. Luego, se crean clases concretas que implementan esta interfaz, proporcionando implementaciones específicas del algoritmo. El contexto (la clase que utiliza el algoritmo) mantiene una referencia a la interfaz Strategy y puede cambiar de estrategia dinámicamente.

=== Ejemplo

El siguiente es un ejemplo de cómo se puede definir y usar el patrón Strategy en Java para implementar diferentes estrategias de compresión de archivos.

[source, java]
----
interface CompressionStrategy {
    void compress(String fileName);
}

class ZipCompressionStrategy implements CompressionStrategy {
    @Override
    public void compress(String fileName) {
        System.out.println("Compressing " + fileName + " using ZIP strategy");
    }
}

class RarCompressionStrategy implements CompressionStrategy {
    @Override
    public void compress(String fileName) {
        System.out.println("Compressing " + fileName + " using RAR strategy");
    }
}

class CompressionContext {
    private CompressionStrategy strategy;

    // Setter para cambiar la estrategia en tiempo de ejecución
    public void setCompressionStrategy(CompressionStrategy strategy) {
        this.strategy = strategy;
    }

    public void createArchive(String fileName) {
        strategy.compress(fileName);
    }
}
----

En este ejemplo, `CompressionStrategy` es la interfaz que define el método `compress`. `ZipCompressionStrategy` y `RarCompressionStrategy` son clases concretas que implementan esta interfaz. `CompressionContext` es la clase que utiliza estas estrategias y permite cambiar la estrategia en tiempo de ejecución.

Para usar este patrón, se puede escribir el siguiente código:

[source, java]
----
public class Main {
    public static void main(String[] args) {
        CompressionContext context = new CompressionContext();

        // Usar la estrategia ZIP
        context.setCompressionStrategy(new ZipCompressionStrategy());
        context.createArchive("file1.txt");

        // Cambiar a la estrategia RAR
        context.setCompressionStrategy(new RarCompressionStrategy());
        context.createArchive("file2.txt");
    }
}
----

En este código, el contexto `CompressionContext` utiliza la estrategia `ZipCompressionStrategy` para comprimir el archivo "file1.txt" y luego cambia a la estrategia `RarCompressionStrategy` para comprimir el archivo "file2.txt".

=== Consideraciones y Mejores Prácticas

El patrón Strategy es especialmente útil cuando se tiene una familia de algoritmos y se necesita intercambiarlos de manera flexible. Sin embargo, es importante asegurarse de que todas las estrategias sean intercambiables y que cada una implemente la interfaz de manera consistente. Además, el uso de este patrón puede incrementar el número de clases en un sistema, por lo que es esencial evaluar si la complejidad adicional es justificada.

=== Ejemplo de Uso en Entorno Multihilo

El siguiente ejemplo muestra cómo aplicar el patrón Strategy en un entorno multihilo para garantizar que las estrategias se utilicen de manera segura:

[source, java]
----
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardPaymentStrategy implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using Credit Card");
    }
}

class PayPalPaymentStrategy implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using PayPal");
    }
}

class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    public synchronized void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}
----

En este ejemplo, `PaymentStrategy` es la interfaz que define el método `pay`. `CreditCardPaymentStrategy` y `PayPalPaymentStrategy` son las implementaciones concretas. La clase `ShoppingCart` utiliza la estrategia seleccionada para realizar el pago, y el método `setPaymentStrategy` es sincronizado para asegurar la seguridad en un entorno multihilo.







